## 자바스크립트 작동 방식 : 이벤트 루프 및 비동기 프로그래밍 + async/await를 사용하여 더 나은 코딩을 위한 5가지 방법

자바스트립트와 그 구성요소를 탐색하는데 전념하는 시리즈 4번째 게시판에 오신것을 환영합니다.
핵심 요소를 식별하고 설명하는 과정에서 경쟁력을 유지하기 위해 견고하고 뛰어난 성능을 갖춘 자바스크립트 응용 프로그램 인 [SessionStack](https://www.sessionstack.com/?utm_source=medium&utm_medium=blog&utm_content=Post-4-eventloop-intro)을 구축할때 사용하는 몇 가지 좋은규칙을 공유합니다.

처음 3챕터들을 놓치셨습니까?? 여기에서 찾을 수 있습니다. (이글은 4번째 챕터임..)

1. [An overview of the engine, the runtime, and the call stack](https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf)(엔진, 런타임 그리고 콜스택에 대한 개요)
2. [Inside Google’s V8 engine + 5 tips on how to write optimized code](https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e)(Google의 V8 엔진 + 최적화된 코드 작성 방법에 대한 5가지 팁)
3. [Memory management + how to handle 4 common memory leaks](https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec)(메모리 관리 + 4 개의 공통 메모리 누출 처리 방법)

이번에는 싱글 스레드 환경에서 프로그래밍의 단점을 검토하고 이를 극복하여 멋진 Javascript Ui를 구축하는 방법을 통해 첫 번째 게시물을 확장 해 보곘습니다.
전통에 따라 글 마지막 부분에 async / await를 사용하여 깨끗한 코드를 작성하는 방법에 대한 5가지 팁을 공유할 것입니다.

#### 왜 싱글 스레드는 제한 적인 것일까?

첫 번째 게시물에서 우리는 처리하는 데 엄청난 시간이 걸리는 콜 스택에 함수 호출이 있을 때 어떤 일이 일어나는지 고민했습니다.
예를 들어 브라우저에서 실행되는 복잡한 이미지 변환 알고리즘을 상상해봅시다.

콜 스택에는 실행 기능이 있지만 브라우저는 다른 작업을 수행 할 수 없습니다. - 차단되고 있습니다.
브라우저가 렌더링 할 수 없으며, 다른 코드를 실행할 수 없다는 것을 의미합니다. 단지 막혔습니다. 
그리고 여기에 문제가 있는데 앱 UI가 더 이상 효율적이고 만족스럽지 않습니다.

앱이 작동하지 않습니다.

어떤 경우에는 이런 문제가 그렇게 중요한 문제가 아닐 수도 있습니다. 
하지만, 여기 더 큰 문제가 있습니다. 브라우저가 콜 스택에서 너무 많은 작업을 처리하기 시작하면 오랫동안 응답이 중단될 수 있습니다. 
그 시점에서 많은 브라우저가 오류를 제기하여 페이지를 종료해야하는지 여부를 묻는 조치를 취할 것입니다.

못생겼으며 그리고 UX를 완전히 망쳐버립니다.

<img src="https://cdn-images-1.medium.com/max/1600/1*MCt4ZC0dMVhJsgo1u6lpYw.jpeg" width="500" alt="">  

#### 자바스크립트 프로그램의 building blocks 구성 

자바 스크립트 애플리케이션을 하나의 .js 파일로 작성할 수도 있지만, 프로그램은 여러 블록으로 구성되어 있으며 그 중 하나만 실행되고 나머지는 나중에 실행됩니다. 가장 일반적인 블록 단위는 함수입니다.

대부분의 개발자들이 자바스크립트에 대해 처음 접하게 된 문제는 나중에 엄격하게 그리고 지금 당장 일어날 필요는 없다는 것을 이해하는 것입니다.
다른 말로 표현하자면, 현재 완료하지 못하는 업무(혹은 할 일)들은 비동기식으로 완료 되며 이것은 당신이 무의식적으로 예상했거나 바라는 바로써 위에서 언급한 방해 행위를 하지 않는다는 것을 의미합니다.

다음 예제를 살펴 보겠습니다.

```javascript
// ajax(..) is some arbitrary Ajax function given by a library
var response = ajax('https://example.com/api');

console.log(response);
// `response` won't have the response
```

표준 Ajax 요청은 동기식으로 완료되지 않는다는 것을 알고있을 것입니다. 
즉, 코드 실행시 ajax(..) 함수는 응답 변수에 할당되기 위해 되돌아 갈 값이 아직 없음을 의미합니다.

비동기 함수가 결과를 반환하도록 "waiting"하는 간단한 방법은 callback이라는 함수를 사용하는 것입니다:

```javascript
ajax('https://example.com/api', function(response) {
    console.log(response); // `response` is now available
});
```

참고 사항 : 실제로 동기식 Ajax 요청을 만들 수 있습니다. 절대로 그렇게하지 마십시오.  
동기식 Ajax 요청을하면 자바 스크립트 앱의 UI가 차단되어 사용자가 클릭하거나 데이터를 입력하거나 탐색하거나 스크롤 할 수 없습니다. 
이렇게하면 사용자 상호 작용이 방지됩니다. 그것은 끔찍한 연습입니다.

이렇게 생겼지만, 그러나 절대로 하지마세요. 웹을 망쳐 놓지 마세요:

```javascript
// This is assuming that you're using jQuery
jQuery.ajax({
    url: 'https://api.example.com/endpoint',
    success: function(response) {
        // This is your callback.
    },
    async: false // And this is a terrible idea
});
```

우리는 Ajax 요청을 예제로 사용했습니다. 코드를 비동기 적으로 실행할 수 있습니다.  
이 작업은 setTimeout (콜백, 밀리 초) 함수를 사용하여 수행 할 수 있습니다.  
setTimeout 함수는 이벤트 (시간 초과)를 나중에 설정하도록 설정합니다. 한 번 봅시다: 

```javascript
function first() {
    console.log('first');
}
function second() {
    console.log('second');
}
function third() {
    console.log('third');
}
first();
setTimeout(second, 1000); // Invoke `second` after 1000ms
third();
```

콘솔의 출력은 다음과 같습니다:
```
first
third
second
```
#### 이벤트 루프 분석

우리는 비동기 자바 스크립트 코드 (예 : setTimeout과 같은)를 허용하면서 ES6까지 자바 스크립트 자체에 실제로 비동기라는 직접적인 개념이 없었던 것은 다소 이상한 주장으로 시작합니다. JavaScript 엔진은 주어진 순간에 프로그램의 단일 덩어리를 실행하는 것 이상을 수행하지 않습니다.

자바 스크립트 엔진이 작동하는 방식 (Google의 V8 구체적)에 대한 자세한 내용은 이 주제에 대한 이전 기사중 하나를 확인해보세요.

그럼, JS 엔진에 프로그램 일부를 실행하라고 누가 지시한 겁니까? 실제로 JS 엔진은 독립적으로 실행되지 않습니다. 
대부분의 개발자가 일반적인 웹 브라우저 또는 Node.js인 호스팅 환경에서 실행됩니다. 
사실, 요즘, 자바스크립트는 로봇에서 전구에 이르기까지 모든 종류의 장치에 내장되어 있습니다. 모든 단일 장치는 JS 엔진의 다른 유형의 호스팅 환경을 나타냅니다.

모든 환경에서 공통 분모는 JS 엔진을 호출할 때마다 시간이 지남에 따라 프로그램의 여러 덩어리를 실행하는 이벤트 루프라는 내장 메커니즘입니다.  

즉, JS 엔진은 임의의 JS 코드에 대한 주문형 실행 환경 일뿐입니다. 이벤트를 예약하는 것은 주변 환경(JS 코드 실행)입니다.

예를 들어, JavaScript 프로그램이 서버에서 데이터를 가져 오기 위해 Ajax 요청을할 때 함수 ( "호출")에 "응답"코드를 설정하고 JS 엔진은 호스팅 환경에 대해 알려줍니다.
“이봐, 지금 당장은 실행을 중지할 테지만, 네트워크 요청을 끝내고 데이터가 있을 때마다 이 기능을 다시 불러줘.”

그런 다음 브라우저가 네트워크의 응답을 청취하도록 설정되고, 다시 반환할 것이 있으면 이벤트 루프에 삽입하여 콜백 기능을 실행하도록 예약합니다. 

아래 다이어그램을 살펴봅시다:

<img src="https://cdn-images-1.medium.com/max/1600/1*FA9NGxNB6-v1oI2qGEtlRQ.png" width="600" alt="">  


